***3. 抽象数据类型和面向对象编程***


# 3.1 数据类型和类型检查

## 1. 数据类型

变量：用特定数据类型定义，可存储满足类型约束的值

**java中的数据类型**

- 基本数据类型
- 对象数据类型

![](_v_images/_1528778690_28285.png)

**对象类型形成层次结构**

- 根是 Object
- 继承关系
- ![](_v_images/_1528778766_28585.png)

**包装类**

- 将基本类型包装为对象类型
    - Boolean, Integer, Short, Long, Character, Float, Double
- 通常是在定义集合类型的时候使用它们
- 一般情况下，尽量避免使用
- 一般可以自动转换

**重载 Overloading operators**

-同样的操作名可用于不同的数据类型

## 2. 静态和动态数据类型

- java是一种静态类型语言
    - 在编译阶段进行类型检查
- 动态类型语言：python
    - 在运行阶段进行类型检查

## 3. 类型检查

类型转换

![](_v_images/_1528781436_32478.png)

- 静态类型检查——程序运行前
    - 可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。
    - 检查出来的错误类型包括
        - 语法错误
        - 类名/函数名错误
        - 参数数目错误
        - 参数类型错误
        - 返回值类型错误
    - ![](_v_images/_1529309136_6574.png)
- 动态类型检查——程序运行后
    - 检查出来的错误类型包括
        - 非法的参数值
        - 非法的返回值
        - 越界
        - 空指针
    - ![](_v_images/_1529309255_11234.png)
- 无检查

**静态检查：**关于“类型”的检查，不考虑值

**动态检查：**关于“值”的检查。

## 4. 可变性与不变性

- 改变一个变量：将该变量指向另一个值的存储空间
- 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的止、
- 变化是罪恶的，但程序不能没有变化，但是要尽可能的避免变化，以避免副作用。

### immutability 不变性

- 重要的设计原则
- 不变数据类型：一旦被创建，其值不能改变
- 如果是引用类型，也可以是不变的，一旦确定其指向的对象，不能再被改变
    - 使用`final`来确保不变性
- 如果编译器无法确定`final`变量不会改变，就提示错误，这也是静态类型检查的一部分。
- 所以，尽量使用`final`变量作为方法的输入参数、作为局部变量
- `final`表明了程序员的一种设计决策

注：

1. `final`类无法派生子类
2. `final`变量无法改变值/引用
3. `final`方法无法被子类重写

### 可变性与不变性

**不变对象：**一旦被创建，始终指向同一个值/引用
**可变对象：**拥有方法可以修改自己的值/引用

举个栗子

- `String`是个不可变的
- ![](_v_images/_1529316001_18648.png)
- `StringBuilder`是可变的
- ![](_v_images/_1529316030_118.png)

看起来都是一样，事实上，当只有一个引用指向该值，没有区别，**但是，有多个引用的时候，差异就出现了**

![](_v_images/_1529316220_21137.png)

### 可变类型的优势

- 使用不可变类型，对其频繁修改会产生大量的临时拷贝（需要垃圾回收）
    - 第一个字符被拷贝了 n 次， 第二个被拷贝了 n-1 次，......
    - 事实上，花费了 O(n^2) 的时间去连接 n 个元素
- 可变类型最少化拷贝以提高效率
- ![](_v_images/_1529316591_12.png)
- 使用可变数据类型，可以获得更好的性能
- 也适合在多个模块之间共享数据

### 变化的风险

- 不可变类型更**安全**，在其他质量指标上表现更好
- 折中，看你看重哪个质量指标

**有风险的例子1：传递可变的值**

![](_v_images/_1529317016_726.png)

改变了输入参数的值，导致 list 中都变成了正数。

### 防御式拷贝

通过防御式拷贝，给客户端返回一个全新的对象，但是大部分时候该拷贝不会被客户端修改，可能造成大量的内存浪费

如果使用不可变类型，则节省了频繁复制的代价

## 5. 快照图

- 用于描述程序运行时的内部状态
- 使用快照图可以
    - 便于程序员之间的交流
    - 便于刻画各类变量随时间变化
    - 便于解释设计思路

**基本类型的值 Primitive values**

![](_v_images/_1529321898_16924.png)

**对象类型的值 Object values**

![](_v_images/_1529321921_4320.png)

**不可变对象：双线椭圆**

![](_v_images/_1529321859_19724.png)

**可变对象：单线椭圆**

![](_v_images/_1529321992_29992.png)

**不可变的引用：双箭头**

![](_v_images/_1529322155_1861.png)

- 引用是不可变的，但指向的值却可以是可变的
- 可变的引用，也可指向不可变的值

从练习中可以认识到

- final 修饰的变量，无法再次更改（分配，即再new一个）
    - 静态检查即可发现
    - ![](_v_images/_1529322741_16902.png)
- 可变与不可变对象的差异
    - ![](_v_images/_1529322778_29867.png)

## 6. 复杂的数据类型: Arrays and Collections

**List**

- List 是一个接口
- List 中的成员必须是一个对象
- ![](_v_images/_1529323132_20849.png)

**Set**

![](_v_images/_1529323201_17581.png)

**Map**

![](_v_images/_1529323237_22336.png)

我们不能创建一个基本数据类型的集合，Set<int> does not work，Set<Integer> numbers is ok。

基本的遍历方式

![](_v_images/_1529323427_32738.png)

使用迭代器遍历

![](_v_images/_1529323502_13662.png)

自己写的一个迭代器

![](_v_images/_1529323681_21872.png)

![](_v_images/_1529325189_32282.png)

![](_v_images/_1529325201_26371.png)

![](_v_images/_1529325219_11487.png)

![](_v_images/_1529325234_26741.png)

从例子中可以学到
- 可变性会暗中破坏一个迭代器
- 正确的打开姿势
    - ![](_v_images/_1529325175_1950.png)

### 7. 有用的不可变类型

- 基本类型以及其封装对象类型都是不可变的
    - 计算大数字的时候，BigInteger 和 BigDecimal 也是不可变的
    - 不要使用`Date`，use the appropriate immutable type from `java.time` or `java.time.ZonedDateTime`based on the granularity of timekeeping you need.
    - 一般用到的集合的接口都是可变的
    - java 提供了












