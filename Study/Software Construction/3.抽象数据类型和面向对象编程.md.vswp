vnote_backup_file_826537664 C:/Users/99789/Documents/vnote_notebooks/Study/Software Construction/3.抽象数据类型和面向对象编程.md
***3. 抽象数据类型和面向对象编程***

3-1节研究了“数据类型”及其特性
3-2节研究了方法和操作的“规约”及其特性
3-3节将数据和操作复合起来，构成ADT，学习ADT的核心特征，以及如何设计“好的”ADT



* [3\.1 数据类型和类型检查](#31-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5)
  * [1\. 数据类型](#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
  * [2\. 静态和动态数据类型](#2-%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
  * [3\. 类型检查](#3-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5)
  * [4\. 可变性与不变性](#4-%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E4%B8%8D%E5%8F%98%E6%80%A7)
    * [immutability 不变性](#immutability-%E4%B8%8D%E5%8F%98%E6%80%A7)
    * [可变性与不变性](#%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E4%B8%8D%E5%8F%98%E6%80%A7)
    * [可变类型的优势](#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF)
    * [变化的风险](#%E5%8F%98%E5%8C%96%E7%9A%84%E9%A3%8E%E9%99%A9)
    * [防御式拷贝](#%E9%98%B2%E5%BE%A1%E5%BC%8F%E6%8B%B7%E8%B4%9D)
  * [5\. 快照图](#5-%E5%BF%AB%E7%85%A7%E5%9B%BE)
  * [6\. 复杂的数据类型: Arrays and Collections](#6-%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-arrays-and-collections)
  * [7\. 有用的不可变类型](#7-%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B)
  * [8\. 空引用](#8-%E7%A9%BA%E5%BC%95%E7%94%A8)

# 3.1 数据类型和类型检查

## 1. 数据类型

变量：用特定数据类型定义，可存储满足类型约束的值

**java中的数据类型**

- 基本数据类型
- 对象数据类型

![](_v_images/_1528778690_28285.png)

**对象类型形成层次结构**

- 根是 Object
- 继承关系
- ![](_v_images/_1528778766_28585.png)

**包装类**

- 将基本类型包装为对象类型
    - Boolean, Integer, Short, Long, Character, Float, Double
- 通常是在定义集合类型的时候使用它们
- 一般情况下，尽量避免使用
- 一般可以自动转换

**重载 Overloading operators**

-同样的操作名可用于不同的数据类型

## 2. 静态和动态数据类型

- java是一种静态类型语言
    - 在编译阶段进行类型检查
- 动态类型语言：python
    - 在运行阶段进行类型检查

## 3. 类型检查

类型转换

![](_v_images/_1528781436_32478.png)

- 静态类型检查——程序运行前
    - 可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。
    - 检查出来的错误类型包括
        - 语法错误
        - 类名/函数名错误
        - 参数数目错误
        - 参数类型错误
        - 返回值类型错误
    - ![](_v_images/_1529309136_6574.png)
- 动态类型检查——程序运行后
    - 检查出来的错误类型包括
        - 非法的参数值
        - 非法的返回值
        - 越界
        - 空指针
    - ![](_v_images/_1529309255_11234.png)
- 无检查

**静态检查：**关于“类型”的检查，不考虑值

**动态检查：**关于“值”的检查。

## 4. 可变性与不变性

- 改变一个变量：将该变量指向另一个值的存储空间
- 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的止、
- 变化是罪恶的，但程序不能没有变化，但是要尽可能的避免变化，以避免副作用。

### immutability 不变性

- 重要的设计原则
- 不变数据类型：一旦被创建，其值不能改变
- 如果是引用类型，也可以是不变的，一旦确定其指向的对象，不能再被改变
    - 使用`final`来确保不变性
- 如果编译器无法确定`final`变量不会改变，就提示错误，这也是静态类型检查的一部分。
- 所以，尽量使用`final`变量作为方法的输入参数、作为局部变量
- `final`表明了程序员的一种设计决策

注：

1. `final`类无法派生子类
2. `final`变量无法改变值/引用
3. `final`方法无法被子类重写

### 可变性与不变性

**不变对象：**一旦被创建，始终指向同一个值/引用
**可变对象：**拥有方法可以修改自己的值/引用

举个栗子

- `String`是个不可变的
- ![](_v_images/_1529316001_18648.png)
- `StringBuilder`是可变的
- ![](_v_images/_1529316030_118.png)

看起来都是一样，事实上，当只有一个引用指向该值，没有区别，**但是，有多个引用的时候，差异就出现了**

![](_v_images/_1529316220_21137.png)

### 可变类型的优势

- 使用不可变类型，对其频繁修改会产生大量的临时拷贝（需要垃圾回收）
    - 第一个字符被拷贝了 n 次， 第二个被拷贝了 n-1 次，......
    - 事实上，花费了 O(n^2) 的时间去连接 n 个元素
- 可变类型最少化拷贝以提高效率
- ![](_v_images/_1529316591_12.png)
- 使用可变数据类型，可以获得更好的性能
- 也适合在多个模块之间共享数据

### 变化的风险

- 不可变类型更**安全**，在其他质量指标上表现更好
- 折中，看你看重哪个质量指标

**有风险的例子1：传递可变的值**

![](_v_images/_1529317016_726.png)

改变了输入参数的值，导致 list 中都变成了正数。

### 防御式拷贝

通过防御式拷贝，给客户端返回一个全新的对象，但是大部分时候该拷贝不会被客户端修改，可能造成大量的内存浪费

如果使用不可变类型，则节省了频繁复制的代价

## 5. 快照图

- 用于描述程序运行时的内部状态
- 使用快照图可以
    - 便于程序员之间的交流
    - 便于刻画各类变量随时间变化
    - 便于解释设计思路

**基本类型的值 Primitive values**

![](_v_images/_1529321898_16924.png)

**对象类型的值 Object values**

![](_v_images/_1529321921_4320.png)

**不可变对象：双线椭圆**

![](_v_images/_1529321859_19724.png)

**可变对象：单线椭圆**

![](_v_images/_1529321992_29992.png)

**不可变的引用：双箭头**

![](_v_images/_1529322155_1861.png)

- 引用是不可变的，但指向的值却可以是可变的
- 可变的引用，也可指向不可变的值

从练习中可以认识到

- final 修饰的变量，无法再次更改（分配，即再new一个）
    - 静态检查即可发现
    - ![](_v_images/_1529322741_16902.png)
- 可变与不可变对象的差异
    - ![](_v_images/_1529322778_29867.png)

## 6. 复杂的数据类型: Arrays and Collections

**List**

- List 是一个接口
- List 中的成员必须是一个对象
- ![](_v_images/_1529323132_20849.png)

**Set**

![](_v_images/_1529323201_17581.png)

**Map**

![](_v_images/_1529323237_22336.png)

我们不能创建一个基本数据类型的集合，Set<int> does not work，Set<Integer> numbers is ok。

基本的遍历方式

![](_v_images/_1529323427_32738.png)

使用迭代器遍历

![](_v_images/_1529323502_13662.png)

自己写的一个迭代器

![](_v_images/_1529323681_21872.png)

![](_v_images/_1529325189_32282.png)

![](_v_images/_1529325201_26371.png)

![](_v_images/_1529325219_11487.png)

![](_v_images/_1529325234_26741.png)

从例子中可以学到
- 可变性会暗中破坏一个迭代器
- 正确的打开姿势
    - ![](_v_images/_1529325175_1950.png)

## 7. 有用的不可变类型

- 基本类型以及其封装对象类型都是不可变的
    - 计算大数字的时候，BigInteger 和 BigDecimal 也是不可变的
    - 不要使用`Date`，use the appropriate immutable type from `java.time` or `java.time.ZonedDateTime`based on the granularity of timekeeping you need.
    - 一般用到的集合的接口都是可变的
- 但是 java 提供了对集合的包装类
    - ![](_v_images/_1529326189_29664.png)
- 这种包装器得到的结果是不可变的：即只能看
    - 使一个 list 看起来像一个 list，但是，它的任何操作都会抛出异常，比如，`set(), add(), remove(), etc`
- 但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查
    - 但是当你运行时，比如你要对一个 list 进行 sort() ，此时就会抛出异常
    - ![](_v_images/_1529326548_1477.png)

这种无法改变的封装器主要有两个目的

- 确保一个集合自建立之初就是不可变的
- 使客户端对自己的数据结构是只读状态

![](_v_images/_1529326784_23701.png)

## 8. 空引用

- 基础数据类型不能是`null`，并且编译器会使用静态检查报错，比如`int size = null; //illegal`
- ![](_v_images/_1529327045_4251.png)
- `null`和空串或者空数组不一样。
- 非基础数据类型的数组和像 list 一样的集合都是不`null`但是可以保存 `null`作为值。
- ![](_v_images/_1529327484_29020.png)
- ![](_v_images/_1529327487_9740.png)

# 3.2 设计规格说明

>- 方法的规约
>- 前置/后置条件
>- 欠定规约、非确定规约
>- 陈述式、操作式规约
>- 规约的强度及其比较
>- 如何写出好的规约

## 1. 编程的函数和方法

在静态类型检查阶段完成

- 参数类型是否匹配，
- 返回值类型是否匹配

**一个完整的方法**

![](_v_images/_1529374595_1822.png)


## 2. specification（规格说明）

### 1）编程中的文档

java API 文档实例

**Hacking vs. Engineering**

![](_v_images/_1529374967_14608.png)

### 2）方法的 specification 和 Contract

Spec 给供需双方都确定了责任，在调用的时候双方都要遵守

![](_v_images/_1529375144_985.png)

**规约的特点**

- 规约可以隔离“变“，无需通知客户端
- 规约也可以提高代码效率
- 规约：扮演防火墙的角色
    - 解耦，即不需要了解具体实现
    - ![](_v_images/_1529375273_32469.png)
- 客户和对象之间的协议
    - 输入/输出的数据类型
    - 功能和正确性
    - 性能
- 只讲”能做什么“，不讲”怎么实现“

### 3）行为等价性

**要站在客户端视角来看行为等价性**

- 根据规约来判断行为是否等价
    - ![](_v_images/_1529375615_17481.png)
    - 如果都满足，则等价
- specification 永远不应该讨论方法的`local variables`和方法所在类的`private field`，因为与实现无关。

### 4）Specification 结构：前置/后置条件

- 前置条件：`requires`
    - 对客户端的约束，在使用方法时必须满足的条件
- 后置条件：`effects`
    - 对开发者的约束，方法结束时必须满足的条件
- 契约
    - 如果前置条件满足了，后置条件必须满足
        - ![](_v_images/_1529375894_14177.png)
    - 前置条件不满足，则方法可做任何事情
        - ![](_v_images/_1529375916_8114.png)
        - 你违约在先，我自然不遵守承诺

**Specification in java**

- 静态类型声明是一种规约，可据此进行静态类型检查
- 方法前的注释也是一种规约，但需人工判定其是否满足
- ![](_v_images/_1529376072_15907.png)

**一个栗子**

![](_v_images/_1529376121_18451.png)

![](_v_images/_1529376124_30760.png)

![](_v_images/_1529376267_28798.png)

- 除非在后置条件中声明过，否则方法内部不应该改变输入参数
- 应尽量遵循此规则，尽量不设计 mutating 的 Spec，否则就容易引发 bugs
- 程序员之间应该达成的默契：除非 Spec 必须如此，否则不应修改键入参数
- 可变的对象会使得非常简单的 Specification 变的非常复杂，因此应尽量避免使用 mutable 的对象
    - 程序中可能有很多变量指向同一个可变对象（别名）
    - 无法强迫类的实现体和客户端不保存可变变量的别名
    - 避免使用可变的全局变量，但是有时候为了性能，有时候不得不用，这对程序的安全性造成了很大破坏
    - 可变数据类型导致程序修改变得异常困难

**一个栗子**

![](_v_images/_1529399957_14779.png)

![](_v_images/_1529400080_22670.png)

这个看起来好像数组是新的，但是不能保证使用者不使用别名，更不能保证使用者改变这个数组或者在复用它

![](_v_images/_1529400122_23646.png)

关键就在不可变，在规约里限定住。

### 5）测试 Spec

Javadoc

- 实际的方法
- 说明每一个变量，每一个返回值，每一个异常
- 不说明实现的细节

![](_v_images/_1529400222_22196.png)

**黑盒测试**

## 3. 设计Spec

### 1）对 Spec 分类

对比 Spec——用于判断哪个规约更好

- 规约的确定性
- 规约的陈述性
- 规约强度

#### Stronger vs. weaker specs

- 规约的强度 S2 > S1 
    - S2 的前置条件更弱
    - S1 的后置条件更强
- 就可以用 S2 代替 S1
- Spec 变强：更放松的前置条件 + 更严格的后置条
件

**一个栗子**

![](_v_images/_1529400998_2721.png)

![](_v_images/_1529401060_14172.png)

![](_v_images/_1529401072_27340.png)

![](_v_images/_1529401185_28548.png)

when a specification is strengthened :

![](_v_images/_1529401300_24690.png)

#### Deterministic vs. underdetermined specs

- 确定的规约（Deterministic）：给定一个满足 precondition 的输入，其输出是唯一的、明确的
- 欠定的规约（Under-deterministic）：同一个输入可以有多个输出
    - 欠定的规约通常也有确定的实现
- 非确定的规约（Nondeterministic）：同一个输入，多次执行时得到的输出可能不同

#### Declarative vs. operational specs

- 操作式规约：例如：伪代码
    - 程序员希望向使用者解释实现，但是不要这么做
    - 内部实现的细节不在规约里呈现，放在代码实现体内部注释里呈现
- 声明式规约：没有内部实现的描述，只有“初-终”状态
    - 更有价值

**一个栗子**

![](_v_images/_1529402136_15322.png)

### 2）图形 Spec

- 每一个在这个空间的点表示一个方法实现
- ![](_v_images/_1529402362_23736.png)
- 一个 Spec 定义了一个空间中所有可能执行的区域
- 某个具体实现，若满足规约，则落在其范围内：否则，在其之外
- 程序员可以在规约的范围内自由选择实现方式
- 客户端无需了解具体使用了哪个实现
- 更强的规约，表达为更小的范围
    - ![](_v_images/_1529412920_795.png)
    - 更强的后置条件意味着实现的自由度更低了-》在图中面积变小
    - 更弱的前置条件意味着实现时要处理更多的可能输入，实现的自由度低了-》面积更小

![](_v_images/_1529413193_23527.png)

### 3）设计一个好的 Spec

1. 应该是内聚的（coherent）
    1. Spec 描述的功能应单一，简单，易理解。
2. 信息丰富
    1. ![](_v_images/_1529413428_30540.png)
    2. 不能让客户端产生理解的歧义
3. 足够强
    1. ![](_v_images/_1529413514_12140.png)
    2. 没有充分阐明遇到`null`之后参数是否变化
4. 足够弱
    1. ![](_v_images/_1529413616_13585.png)
    2. is a bad specification，这个文件是读还是写，是已经存在的还是需要创建的
5. 使用抽象类型
    1. 在规约中使用抽象类型，可以给方法的实现体与客户端更大的自由度
6. 前置还是后置？
    1. 是否应该使用前置条件？在方法正式执行之前，是否要检查前置条件已被满足？
    2. 对程序员来说，不写 Precondition，就要在代码内部check；若代价太大，在规约中加入 precondition，把责任交给 client
    3. 对使用者来说，客户端不喜欢太强的precondition，不满足precondition的输入会导致失败。
        1. 惯用做法是：不限定太强的precondition，二是在postcondition中抛出异常：输入不合法
        2. 尽可能在错误的根源处fail，避免其大规模扩散
        3. 衡量标准：检查参数合法性的代价多大？

**总结**

是否使用前置条件取决于

- check 的代价
- 方法的使用范围

注：

- 如果只在类的内部使用该方法(private)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client；
- 如果在其他地方使用该方法(public)，那么必须要使用前置条件，若client端不满足则方法抛出异常


# 3.3 抽象数据类型

>- 抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在的bug——在client和implementer之间建立“防火墙”
>- ADT 的特性：不变量，表示泄露，抽象函数 AF，表示不变量 RI
>- 基于数学的形式对 ADT 这些核心特征进行描述并应用于设计中。

## 1. 抽象和用户定义类型

- 数据抽象：由一组操作所刻画的数据类型
- 传统的类型定义：关注数据的具体表示
- 抽象类型：强调“作用于数据上的操作”，程序员和客户端无需关心数据如何具体存储，只需设计/使用操作即可

## 2. 把类型和操作分类

**类型**

- 可变类型的对象：提供了可改变其内部数据的值的操作
- 不变数据类型：其操作不改变内部值，而是构建新的对象

**抽象类型的操作**

- Creators 构造器
    - 可能实现为构造函数或静态函数
    - 静态函数实现通常也称为工厂方法
- Producer 生产器
    - String 中的concat()方法
- Observers 观察器
    - List 中的 size()
- Mutators 变值器，改变对象属性的方法
    - List 中的 add()
    - 变值器通常返回void，即意味着必然改变了对象的某些内部状态
    - 也可能返回非空类型
- ![](_v_images/_1529465016_17418.png)
- 操作的说明
    - ![](_v_images/_1529465408_29799.png)
    - ![](_v_images/_1529465456_17473.png)

## 3. 抽象数据类型的例子

![](_v_images/_1529465994_3090.png)

## 4. 设计一个抽象数据类型

设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约spec

- 设计简洁、一致的操作
- 要足以支持client对数据所做的所有操作需要，且用操作满足client需要的难度要低
- 要么抽象、要么具体，不要混合--- 要么针对抽象设计，要么针对具体应用的设计

## 5. 表示独立性

- 表示独立性：client 使用 ADT 时无需考虑其内部如何实现，ADT 内部表示的变化不应影响外部 spec 和客户端。
    - ![](_v_images/_1529466463_16375.png)
- 除非 ADT 的操作指明了具体的 pre 和 post-condition，否则不能改变 ADT 的内部表示，--spec规定了 client 和 implement 之间的契约
- ![](_v_images/_1529466647_11762.png)
- ![](_v_images/_1529468066_1009.png)

![](_v_images/_1529470942_11091.png)

## 6. 测试一个抽象数据类型

- 测试 creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足 spec；
- 测试 observers：调用 creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。

**Partition the input spaces of ADT operations**

![](_v_images/_1529475196_23937.png)

**Test suite that covers all partitions**

![](_v_images/_1529475202_8360.png)，![](_v_images/_1529475207_4622.png)

## 7. 不变量

- 一个好的抽象数据结构的最重要的性质就是**保持不变量**
- 不变量：在任何时候总是`true`
- 由 ADT 来负责其不变量，与客户端的任何行为无关
- 为什么需要不变量
    - 保持程序的“正确性”，并容易发现错误
    - `String`是不可变的，你可以使用`String`作为 ADT 的不变量
    - 如果没有这个不变性，那么在所有使用 String 的地方，都要检查其是否改变了

**举个栗子**

![](_v_images/_1529477850_30072.png)

![](_v_images/_1529477867_11224.png)
d
表示泄露

- 不仅影响不变性，也影响了表示独立性
- 无法在不影响客户端的情况下改变其内部表示
- 解决方法
    - private 和 final 的使用

![](_v_images/_1529477876_4237.png)

**接下来这样呢？**

![](_v_images/_1529477894_3553.png)

![](_v_images/_1529477903_2745.png)

解决方法

- 防御式拷贝
- ![](_v_images/_1529477959_4134.png)
- 可变的数据类型通常有一个 copy  的构造器，可以允许你创建一个新的实例来复制
- 另一个方法是 clone ，但是有些类型不支持

**仍然是表示泄露的**

![](_v_images/_1529478121_15537.png)

![](_v_images/_1529478194_11912.png)

解决方法
- 依然是防御式拷贝，直接在构造器里作用
- ![](_v_images/_1529478210_10444.png)

**问题**

- 这样浪费了很多空间，当复制代价很高的时候，需要把这一部分的责任交给客户端，不得不这么做
- ![](_v_images/_1529478322_26645.png)
- 但是由此引发的潜在 bug 也会很多
- 除非迫不得已，否则不要把希望寄托于客户端上，ADT 有责任保证自己的 invariants ，并且避免表示泄露
- 最好的方法就是使用不可变的数据类型，彻底避免表示泄露
- ![](_v_images/_1529478455_1960.png)

**强调：保持不变性和避免表示泄漏，是ADT最
重要的一个Invariant！**

## 8. Rep Invariant and Abstraction Function

![](_v_images/_1529478638_13715.png)

- R：表示空间
    - 一般情况下ADT的表示比较简单，有些时候需要复杂表示
- A：抽象值构成的空间：客户端看到和使用的值

ADT 实现者关注表示空间 R ,用户关注抽象空间 A

![](_v_images/_1529478822_1081.png)

R 和 A 之间的映射关系

- 满射
- 未必单射
- 未必双射
- ![](_v_images/_1529478995_3336.png)

### Abstraction Function

- 抽象函数：R 和 A 之间映射关系的函数
    - AF ： R -》A

### Rep Invariant

- R 和 Boolean之间的映射关系
    - RI ：R -》 boolean
- 表示不变性 RI：某个具体的“表示”是否是“合法的”
    - 也可看作：所有表示值的一个子集，包含了所有合法的表示值
    - 也可看作：一个条件，描述了什么是“合法”的表示值

### RI 和 AF 文档

![](_v_images/_1529482507_22658.png)

双射

### 什么决定了 AF 和 RI

- 抽象值的空间不能决定 AF 和 RI
- 不同的内部表示需要设计不同的 AF 和 RI
- 选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值。
- ![](_v_images/_1529483106_14290.png)
- 即使是同样的 R ,同样的 RI，也可能有不同的 AF ，即“解释不同”
    - ![](_v_images/_1529483264_14938.png)

### RI 和 AF 如何影响 ADT 的设计

- 设计 ADT
    1. 选择 R 和 A
    2. RI --- 合法的表示值
    3. 如何解释合法的表示值 ---映射 AF
- 做出具体的解释：每一个 rep value 如何映射到 abstract value
- 而且要把这种选择和解释明确的写到代码中

**例子**

![](_v_images/_1529503448_24651.png)

- 随时检查 RI 是否满足
- 程序员之间的潜规则：数据都是非空（non-null）

## 9. 有益的可变性

我们应该知道一个抽象值是不应该变化的

- 对于不可变的 ADT 来说，它在 A 空间的 abstract value 应是不变的
- 但其内部表示的 R 空间中的取值则是可以变化的

## 10. AF，RI 和 Safety from Rep Exposure 的文档

在代码中以注释形式记录 AF 和 RI

**一个栗子**

![](_v_images/_1529504138_30985.png)

```java
// Rep invariant:
//     author is a Twitter username (a nonempty string of letters , digits ,underscores)
//     text.length <= 140
// Abstraction Function:
//     represents a tweet posted by author , with content text, at time timstamp
// Safety from rep exposure:
//     all fields are private
//     author and text are Strings, so are guaranteed immutable;
//     timestamp is a mutable Data, so Tweet() constructor and getTimestamp()
//         make defensive copies to avoid sharing the rep's Data object with clients
```

**两个栗子**

![](_v_images/_1529504494_5522.png)

**三个栗子**

![](_v_images/_1529504641_14429.png)

### ADT 的 spec 都在说些什么

- ADT 的规约里只能使用 client 可见的内容来撰写，包括参数，返回值，异常。
- 如果规约里需要提及“值”，只能使用 A 空间中的“值”
- ![](_v_images/_1529504731_8379.png)
- ADT 的规约也不应谈及任何内部表示的细节，以及 R 空间中的任何值
- ADT 的内部表示（私有属性）对外部都应严格不可见
- 故在代码中以注释的形式写出AF和RI而不能在Javadoc文档中，防止被外部看到而破坏表示独立性/信息隐藏

### 如何建立不变量

- 去做一个不变量，我们需要
    - 在对象的初始状态不变量为`true`
    - 在对象发生变化时，不变量也要为`true`
- 将其转化为 ADT 操作的类型
    - 构造器和生产器在创建对象时要确保不变量为`true`
    - 变值器和观察器在执行时必须保持不变性
- 表示泄露的风险
    - 一旦泄露，ADT 内部表示可能会在程序的任何位置发生改变（而不是限制在 ADT 内部），从而无法确保 ADT 的不变量是否能够始终保持为`true`
    - ![](_v_images/_1529505354_1939.png)

![](_v_images/_1529505461_31906.png)

## 11. ADT 不变量代替前置条件

设计良好的抽象数据类型的巨大优势在于它封装和执行了我们必须在前提条件下必须规定的属性。因此，可以用不变量取代方法的Precondition

**举个栗子**

```java
/** 
 * @param set1 is a sorted set of characters with no repeats
 * @param set2 is likewise
 * @return characters that appear in one set but not the other,
 *  in sorted order with no repeats 
 */
static String exclusiveOr(String set1, String set2);
```

改为
```java
/** @return characters that appear in one set but not the other */
static SortedSet<Character> exclusiveOr(SortedSet<Character>  set1, SortedSet<Character> set2);
```

- 因为所需条件（不重复排序）可以在一个地方，SortedSet类型中强制执行，并且由于Java静态检查起作用，阻止不满足此条件的值根本无法使用，在编译时出错。
- 它更容易理解，因为它更简单，并且名称SortedSet传达了程序员需要知道的内容。
- 它更容易进行更改，因为SortedSet现在可以更改表示量而不更改exclusiveOr任何客户端。






















