***8.面向性能编程***

- 8-1 重点学习了memory performance和I/O performance
- 8-2 如何利用工具对运行的程序性能进行动态监控，以发现性能瓶颈，并试图加以消除
- 8-3 如何通过对代码的修改，消除性能瓶颈，提高系统性能？——代码调优、面向性能的设计模式



# 8.1 面向性能的度量和原则以及方法

![](_v_images/_1529715802_24152.png)

![](_v_images/_1529715966_28675.png)

![](_v_images/_1529715994_25903.png)

## 内存管理

### 1. 操作系统层级的内存管理

![](_v_images/_1529716154_21519.png)

一个字节8位，一个字2两个字节，int是4个字节，

内存管理包括

- 内存分配
- 垃圾回收

对象模型

- heap 对象在 heap 堆中分配内存
- 对象引用：指其他对象在堆中的起始地址
- 非基本数据类型的变量等价于对象引用
- 每个对象包含一组变量，每个变量可指向其他对象的引用
- 对象引用只能指向一个其他对象，而一个对象可被多个其他对象所引用

![](_v_images/_1529716591_30067.png)

### 2. 三个对象管理的模式

![](_v_images/_1529716682_31664.png)

- Static 静态
- Stack-based 动态，基于栈
- Heap-based（free）动态，基于堆
- 差异在于：如何与何时在程序对象与内存对象之间建立联系

![](_v_images/_1529716888_19565.png)

![](_v_images/_1529716941_1991.png)

![](_v_images/_1529717158_5593.png)

- 后进先出
- 无法支持复杂数据类型

![](_v_images/_1529717038_1336.png)

![](_v_images/_1529717194_17101.png)

![](_v_images/_1529717217_29274.png)

### 3. java内存模型

![](_v_images/_1529717254_1961.png)

![](_v_images/_1529717362_3979.png)

![](_v_images/_1529717342_17988.png)

![](_v_images/_1529717389_25185.png)

![](_v_images/_1529717429_25612.png)

![](_v_images/_1529717575_7670.png)

![](_v_images/_1529717883_27432.png)

![](_v_images/_1529717995_11183.png)

### 4. 垃圾回收

#### 1. 三种模式的空间释放

![](_v_images/_1529718061_26358.png)

![](_v_images/_1529718101_7929.png)

![](_v_images/_1529718123_22552.png)

#### 2. 可到达的和不可到达的对象

![](_v_images/_1529718162_27956.png)

![](_v_images/_1529718273_169.png)

![](_v_images/_1529718300_20829.png)

![](_v_images/_1529718314_29627.png)

![](_v_images/_1529718358_28193.png)

#### 3. 垃圾回收的定义

![](_v_images/_1529718418_15775.png)

![](_v_images/_1529718433_10621.png)

![](_v_images/_1529718583_21390.png)

![](_v_images/_1529718616_22093.png)

#### 4. 自己做 GC

![](_v_images/_1529718716_11623.png)

#### 5. 自动 GC

#### 6. GC 的基本算法

- 引用计数
- 标记-清除
- 标记-整理
- 复制

![](_v_images/_1529718917_9092.png)

![](_v_images/_1529718961_17059.png)

##### 1. 引用计数

![](_v_images/_1529719026_17880.png)

![](_v_images/_1529719059_11184.png)

![](_v_images/_1529719569_14383.png)

- 引用计数方法的优点：简单、计算代价分散，“幽灵时间”短 -》0
- 引用计数方法的缺点：不全面（容易漏掉循环引用的对象）、并发支持较弱、占用额外内存空间、等。

##### 2. 标记-清除

![](_v_images/_1529720030_29518.png)

![](_v_images/_1529720059_4110.png)

##### 3. 标记-整理

![](_v_images/_1529722402_3796.png)

![](_v_images/_1529722423_31010.png)

##### 4. 复制

**碎片**

![](_v_images/_1529722502_7566.png)

![](_v_images/_1529722519_1399.png)

![](_v_images/_1529722592_4259.png)

![](_v_images/_1529722867_7963.png)

![](_v_images/_1529722883_14763.png)

#### 7. JVM 中的垃圾回收

![](_v_images/_1529723725_22079.png)

![](_v_images/_1529724058_16684.png)

![](_v_images/_1529724086_28189.png)

![](_v_images/_1529724098_20242.png)

#### 8. JVM 中的 GC 协调

![](_v_images/_1529724430_8710.png)

![](_v_images/_1529724449_33.png)

##### 1.  协调 VM heap size
**重要！！！**

![](_v_images/_1529724483_30621.png)

![](_v_images/_1529724509_22445.png)

![](_v_images/_1529724534_12317.png)

![](_v_images/_1529724626_6237.png)

![](_v_images/_1529724672_14494.png)

默认空余堆内存小于40%时，JVM 就会增大堆直到-Xmx 的最大限制，可以由 -XX:MinHeapFreeRatio 指定。 

默认空余堆内存大于70%时，JVM 会减少堆直到-Xms的最小限制，可以由 -XX:MaxHeapFreeRatio 指定，

### 5. 算法性能

### 6. I/O 性能

#### 软件的 I/O

![](_v_images/_1529725481_968.png)

#### Java IO 

![](_v_images/_1529725562_14772.png)

![](_v_images/_1529725800_16422.png)

![](_v_images/_1529725814_10464.png)

看到了 141

# 8.2 动态程序分析方法和工具

## 1. 动态程序分析

![](_v_images/_1529726180_23667.png)

![](_v_images/_1529726239_4776.png)

## 2. 性能分析

实时或周期性的获取/展示程序运行过程中的数据

![](_v_images/_1529726808_28335.png)

![](_v_images/_1529726904_19028.png)

## 3. Java中的性能分析工具

### 1. 命令行

**没有认真看**


# 8.3 代码调优

![](_v_images/_1529727338_25895.png)

![](_v_images/_1529738590_32571.png)



## 1. 单例模式

## 2. 轻量模式

## 3. 原型模式

引用拷贝

对象拷贝

46——54

![](_v_images/_1529738819_14363.png)

## 4. 对象池模式

## 5. 规范化

## 6.字符串常量池

![](_v_images/_1529738969_9299.png)
