10. 并行与分布式编程

[toc]

---

# 10.1 并行性与线程安全
## 1. 并发编程
多个运算同时发生

**原因有三**
- 处理器时钟速度不再增加
- 新一代芯片都会有很多的内核
- 为了让计算更快运行，我们必须将计算分解为并发模块

**两种常见的并发模型**
- 共享内存![](_v_images/_1528070017_4885.png)
    - 例子
        - 两个处理器共享内存
        - 两个程序共享文件
        - 两个线程共享对象
- 消息传递![](_v_images/_1528070039_3370.png)
    - 例子
        - 网络中两台计算机通信
        - web 浏览器和 web server
        - 即使消息的客户端和服务器
        - 通过管道连接两个程序的输入和输出

## 2. 进程，线程
进程和线程是两种不同的并发模块
- 进程是正在运行程序的一个实例，它拥有自己私有专用的内存空间
- 线程是正在运行程序的一个执行路径（一个进程可以对应多个线程），每个线程有自己独立的堆栈和局部变量，但是多个线程共享内存空间。

### 1) 进程
进程可抽象成虚拟计算机，拥有独立的执行环境和完整的资源（内存空间）
- 它使得这个程序好像自己独自占有整台机器

**进程通常不共享内存**
- 进程不能访问其他进程的内存或对象
- 需要特殊机制才能实现进程间共享内存
- 进程通信采用的是消息传递方式（因采用标准 I/O 流）

进程通常被视为程序或者应用，但**事实上，应用程序可能是一组协作进程**，为了实现进程间通信，大多数操作系统都支持“进程间通信（IPC）资源，例如管道和socket
- IPC 不仅在同一系统的不同进程中使用，而且可以在不同系统的进程中被用到。

Java虚拟机本身的大多数实现都是作为单个进程运行的
### 2) 线程
线程可抽象为一个虚拟处理器，有时也被称为轻量级进程。线程与进程中的其他线程共享共同的资源（内存，打开文件等），即”**线程存在于进程内**。

线程采用内存共享机制通信，需要特殊处理才能实现**消息传递和私有内存**。

![](_v_images/_1528073346_6730.png)

每一个应用程序至少有一个线程，从 main 线程开始，创建其他的线程。

两个创建线程的方法
- （很少用）创建 Thread 类的子类
- （大多数）实现 Runnable 接口，作为参数传递给 new Thread() 构造函数

所有的线程都需要实现 Runnable 接口，在 run() 中写具体实现
```java
public interface Runnable {
    void run();
}

//Method1 Subclasss Thread
public class HelloThread extends Thread{
    public void run(){
        System.out.println("Hello");
    }
    public static void main(String args[]){
        (new HelloThread()).start();
        (new HelloThread()).start();
        (new HelloThread()).start();
    }
}
//Method2 Provide a Runnable object
public class HelloRunnable implements Runnable{
    public void run(){
        System.out.println("Hello");
    }
    public static void main(String args[]){
        (new Thread(new HelloRunnable())).start();
    }
}
```

惯用法：用一个匿名的`Runnable`启动一个线程，它避免了创建命名的类
```java
    new Thread(new Runnable(){
        public void run(){
            System.out.println("hello");
        }
    }).start();
```
注：new Runnable () {...} 不是实例化 Runnable 接口（java 不支持对接口的实例化），实际是上一种内部类的简写

- 1. 构造一个实现 Runnable 接口的无名 local 内部类（方法内的内部类）
- 2. 构造这个无名 local 内部类的一个实例
- 3. 用 Runnable 来表示这个无名 local 内部类的类型（OO多态）。

## 3. 交叉存取与竞争条件
**时间切片**

一个运行核心上只有一个线程可以运行

- 进程 / 线程等采用 OS 提供的时间片特征来共享处理时间
- 当线程数多于处理器数量时，并发性通过时间片来模拟，处理器切换处理不同的线程。

**时间片的例子**
![时间片的例子](_v_images/_时间片的例子_1528097120_23552.png)

时间片的使用是不可预知和非确定性的，这意味着线程可能随时暂停或恢复。

共享内存可能会导致微妙的错误。

竞争条件：程序的正确性（后置条件和不变量的满足）取决于并发计算 A 和 B 中事件的相对时间，也叫（线程干扰）（Thread Interference）

**调整代码无济于事**，不能仅仅从 Java 代码中看出处理器将如何执行它，也无法通过观察一个表达式来判断它是否会在竞赛状态下安全。

**消息传递的例子**

模块之间通过消息传递进行交互

- 消息接收方将接受到的消息形成队列逐一处理（先进先出）
- 消息发送者并不停下来等待结果而是继续执行（异步方式）

消息传递的方式并不能消除竞争条件的可能性，在 Java 中，采用 happened-before 机制，保证了语句 A 内存的写入对语句 B 是可见的，从而确保内存一致性。

## 4. 线程安全

数据类型或静态方法在线程中执行时，无论如何执行，不需要调用者做额外的协作，仍然能够行为正确，则称为线程安全。

- 行为正确意味着满足规格说明和保持不变性
- 不能在前置条件中对调用者增加时间性要求 

Iterator 不是线程安全的，因为需要满足特殊约定

**保证线程安全的四个方法**

- 限制可变变量的共享
- 用不可变的共享变量
- 将共享数据封装在线程安全的数据类型中
- 使用同步来防止线程同时访问变量

### 1) Confinement
通过将数据限制在单个线程中，可以避免线程在可变数据上进行竞争

**限制可变变量[^4]**

- 局部变量保存在线程栈中，每一个调用都有自己的变量副本
- 局部变量如果是对象的引用，则要确保不能引用任何其他线程可访问的对象

 ![](_v_images/_1528192737_8846.png)

**避免全局变量**

- 全局静态变量不会自动收到线程访问限制
    - 如果使用了全局静态变量，则应说明只有一个线程会使用它们。
- 在多线程环境中，取消全局变量

### 2) Immutability

使用不可变的引用和数据类型

- 不可变解决了因为共享可变数据造成的竞争，并简单地通过使共享数据不可变来解决他。
- `final` 变量是不可变的引用，所以声明为`final`的变量可以安全的从多个线程访问。
- 因为这种安全性只适用于变量本身，仍然必须确保变量指向的对象是不可变的。

回顾 3.3 不可变性

- 类型是不可变的：如果类型的对象在其整个生命周期中始终表示相同的抽象值
- 但实际上，允许对 rep 进行修改，只要这些改变对客户是不可变的，并且对应的抽象值不变，，例如有益的突变。
- 但是对于并发性，这种隐藏的变化是不安全的，使用有益的变化的不可变数据类型必须使用锁来使自己线程安全。

**更强的不可变性的定义**

- 没有改变数据的操作
    - don not provide "`setter`"methods
- 所有字段均为 private 和 final
    - make all fields `final`and`private`
- 没有表示泄露
    - 不允许子类重写方法
        - 类声明为`final`
        - 更复杂的方法是使构造函数为私有，并使用工厂方法构造实例[^5]
- 表示中的任何可变对象都不能变化
    - 不提供修改可变对象的方法
    - 不要共享对可变对象的引用
    - 不存储传递给构造函数的外部可变对象的引用
    - 避免在方法返回值中包含对可变对象的引用

### 3) Using Threadsafe Data Types
将共享的可变数据存储在线程安全的数据类型中

因为线程安全的数据类型性能较差，所以 Java 对一些可变数据类型提供了两种方式选择：线程安全的和线程不安全的，比如：

- `StringBuffer` 和 `StringBuilder` 都是可变数据类型，功能基本相同
- `StringBuffer` 是线程安全的，`StringBuilder` 不是
- `StringBuilder`性能更好，推荐在单线程程序中使用

**线程安全的 Collection**

- `List，Set，Map`这些都不是线程安全的类型
- Java 提供了线程安全的 Collections 类型版本
    - 确保方法是原子的
    - 原子方法：动作的内部操作不会同其他操作交叉，不会产生部分完成的情况

```java
private static Map<Integer, Boolean> cache = 
    Collections.synchronizedMap(new HashMap<>());
```

**一些要点**

- 不要绕开包装类，统一采用包装类的形式(Don not circumvent the wrapper)[^6]
    - 确保抛弃对底层非线程安全容器类的引用，并只通过同步的包装来访问它
    - 新的`HashMap`只传递给`synchronizedMap`，并且永远不会存储在其他地方
    - 因为底层的容器仍然是可变的，引用它的代码可以规避不变性，失去了包装的意义
- 迭代器仍然是线程不安全的(Iterators are still not threadsafe)
    - 即使`collection`自己调用的`get(), put(), add(), etc`是线程安全的，被`collection`创建的迭代器也是不安全的
    - 所以，你不能使用`iterator(), or the for loop syntax:`
        - `for (String s: list){...}`
    - 解决方法是将在需要迭代`collection`时获取集合的锁[^7]
- 原子操作不足以完全防止竞争，例如检查列表是否至少有一个元素，然后获取该元素
    - `if (!list,isEmpty()) { String s = list .get(0);...}`
    - 即使你已经把 list 变为同步包装的 list ，上述代码依然会有竞争条件，因为另一个线程可能删除一个元素在`isEmpty()call 和 get()call` 之间

![](_v_images/_1528208164_26874.png)

包装的实现是将所有的实际工作委托给指定的容器，但在容器的基础上添加额外的功能。
### 4) Locks and Synchronization
**并发程序的正确性不应依赖于事件的时间。**

Synchronization：防止多个线程同时访问共享数据

- 锁定是一种实现同步的技术
    - 锁是一种抽象，某时刻最多只允许一个线程拥有锁（即意味着一个线程告诉其他的线程：我正在修改这个东西，不要现在动他）
- 锁有两个操作：
    - **acquire：**获取锁的所有权，如果锁被其他进程拥有，那么进入阻塞状态，等待锁释放之后，再与其他进程争夺锁的所有权
    - **release：**释放锁的所有权
- 使用锁还可以确保锁的所有者始终查看最新的数据
- 阻塞一般意味着线程等待（不再继续工作），直到一个事件发生。[^8]

**Recall : Steps to develop an ADT**

- 指定：定义操作
- 测试：为操作设计测试用例
- Rep：选择不变量
    - 简单，强有力
    - 写 AF 和 RI，并且在每一个 constructor, producer, mutator 执行 `CheckRep()`来核对不变量

**加入 Synchronize**
- 阐述如何使 rep 线程安全
- 写入表示不变性的说明中，以便代码维护者知道你使如何为类设计线程安全性的

例子

![](_v_images/_1528241233_29758.png)

不好的方案

![](_v_images/_1528241488_24781.png)

较好的解决方案（类似光标）

![](_v_images/_1528241299_23777.png)

![](_v_images/_1528241321_25238.png)

Gap buffer（示范 RI 和 AF 如何书写）
```java
public class GrpBuffer implements EditBuffer{
    private char[] a;
    private int gapStart;
    private int gapLength;
    //Rep invariant;
    //    a != null
    //    0 <= gapStart <= a.length
    //    0 <= gapLength <= a.length - gapStart
    //Abstraction function
    //    represents the sequence a[0],...a[gapStart - 1], a[gapStart+gapLength],...,a[Length-1]
```

#### (1)Synchronized Blocks and Methods

**Locking**

Java 将锁定机制作为内置语言提供

同步是围绕内部锁或监视器锁实体构建的，（API规范通常将此实体简称为“监视器”）。在同步时：强制对象状态的独占访问和建立 happens-before 关系，内部锁都起作用
- 每个类及其所有对象实例都有一个锁

**Synchronization**

Java 提供了两种基本同步的方法
- 同步方法
- 同步语句/同步代码块（Synchronized Statements)

##### i. Synchronized Statements

- 同步语句必须指定内部锁的对象
- 同步区域提供了互斥功能：一次只能有一个线程处于由给定对象的锁保护的同步区域中。
- 锁定时，遵循顺序执行模式

```java
//lock is an object of a class
synchronized (lock) { // thread blocks here until lock is free
    // now this thread has the lock
    balance = balance + 1;
    // exiting the block releases the lock
}
```

- 锁用于保护共享数据变量，确保原子性
- 使用`synchronized(obj){...}`只能做一件事情：在线程 t 中，会阻止其他线程进入保护块中，直到语句块中代码执行完。
- 锁只能确保与其他请求获取相同对象锁的线程互斥访问
- 有一个**误区：**拥有对象的锁会自动阻止其他线程访问该对象
- 锁只能确保与其他请求获取相同对象锁的线程互斥访问，如果其他线程没有使用`synchronized(obj)`或者利用了不同`object`的锁，则同步会失效

```java
public class ThreadTest_02a extends Thread{
    private String lock;
    private String name;

    public ThreadTest_02a(String name, String lock){
        this.name = name;
        this.lock = lock;
    }

    @Override
    public void run(){
        synchronized (lock){
            for (int i = 0; i < 3; i++) {
                System.out.println(name + " run ...");
            }
        }
    }

    // example1
    public static void main(String[] args) {
        String lock = new String("test");
        for (int i = 0; i < 5; i++){
            new ThreadTest_02a("ThreadTest_" + i,lock).start();
        }
    }

    //example2
    public static void main(String[] args) {
        String lock;
        for (int i = 0; i < 5; i++){
            lock = new String("test");
            new ThreadTest_02a("ThreadTest_" + i,lock).start();
        }
    }
}
```
Example 1

![example1](_v_images/_example1_1528370064_16089.png)

Example 2

![example2](_v_images/_example2_1528370078_16328.png)

造成上面结果不同的原因就是：
- example 1 中，lock 对象只创建了一次，因而确保了获得锁的线程可以去其他请求获取 lock 对象（因为是同一个）的线程互斥访问。
- example 2 中， lock 每次循环都在 new String，所以对象不同，同步就会失效。

**监视器模式**

- 最方便的锁就是`this`
- `synchronized(this)`
- 在 Monitor pattern 中，某时刻只能有一个线程在类的实例中

![](_v_images/_1528371158_4873.png)

##### ii. Synchronization：Synchronized Methods

除了同步代码块之外，还可以同步方法

```java
public synchronized void increment() {c++;}
```

- 当线程调用同步方法时，它会自动获取该方法对象的**内部锁**，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会释放锁。
- 同一对象上的同步方法的两次调用不会有交错现象
- 当一个线程正在执行一个对象的同步方法时，所有其他线程如果调用同一对象的同步方法块，则会挂起执行，直到第一个线程针对此对象的操作完成。
- 当一个同步方法退出时，它会自动建立一个与之后调用同一个对象的同步方法的 happens-before 关系，这保证对象状态的更改对所有线程都是可见的。

**happens-before relationship**

- *happenes-before*保证了语句 A 内存的写入对语句 B 是可见的，也就是在 B 开始读数据之前，A 已经完成了对数据的写入
- 确保了内存一致性

```java
public class ThreadTest3 implements Runnable{
  public synchronized void run() {
    for (int i = 0; i < 3; i++) {
      System.out.println(Thread.currentThread().getName() + "...");
    }
  }
  //example1
  public static void main(String[] args) {
    for (int i = 0; i < 5; i++) {
      new Thread(new ThreadTest3(), "Thread_" + i).start();
    }
  }
  //example2
  public static void main(String[] args) {
    ThreadTest3 threadTest3 = new ThreadTest3();

    for (int i = 0; i < 5; i++) {
      new Thread(threadTest3, "Thread_" + i).start();
    }
  }
}
```
example 1
![](_v_images/_1528375441_31393.png)

example 2
![](_v_images/_1528375458_11734.png)

synchronized methods

![](_v_images/_1528375500_32574.png)

**静态同步方法**

当一个静态同步方法被调用，什么是锁？

- 由于静态方法与类关联，而不是对象，在这种情况下，线程获取与该类关联的`class`对象的内部锁
- 对类的静态字段的访问由与该类的任何实例的锁截然不同的锁来控制

![](_v_images/_1528376900_10399.png)

Synchronized 语句可用于实现具有细粒度同步的并发性

![](_v_images/_1528377040_30627.png)

**Locking Discipline**

- 锁定规则是确保同步代码是线程安全的策略
- 我们必须明确两个条件
    - 每个共享的可变变量必须由每个锁保护
    - 如果一个不变量涉及多个共享的可变变量（甚至可能在不同的对象中），那么涉及的所有变量都必须由相同的锁保护
- 监视器模式满足这两个规则，rep 中所有共享的可变数据（表示不变量依赖的）都被相同的锁保护

State model for Java threads：locking

![](_v_images/_1528378476_32081.png)

#### (2)Atomic operations

![](_v_images/_1528378698_22407.png)

让数据类型的锁对客户端可用，以实现更高级的原子操作

![](_v_images/_1528378737_20514.png)

![](_v_images/_1528378715_31953.png)

扩大了同步的区域

#### 